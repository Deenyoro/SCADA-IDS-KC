name: Build Windows Executable

on:
  push:
    branches: [ main, develop ]
    tags: [ 'v*' ]
  pull_request:
    branches: [ main ]
  workflow_dispatch:
    inputs:
      python_version:
        description: 'Python version to use'
        required: false
        default: '3.11.9'
      create_release:
        description: 'Create GitHub release'
        required: false
        default: false
        type: boolean

env:
  PYTHON_VERSION: ${{ github.event.inputs.python_version || '3.11.9' }}

jobs:
  build-windows:
    runs-on: ubuntu-22.04  # Use Ubuntu 22.04 for better Wine support
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Cache Wine and Python installer
      uses: actions/cache@v4
      with:
        path: |
          ~/.cache/winetricks
          ~/.wine_scada_build
          python-3.11.9-amd64.exe
        key: ${{ runner.os }}-wine-python-${{ env.PYTHON_VERSION }}
        restore-keys: |
          ${{ runner.os }}-wine-python-

    - name: Download Windows Python installer
      run: |
        echo "ğŸ“¥ Downloading Windows Python installer..."
        if [ ! -f "python-3.11.9-amd64.exe" ]; then
          wget -q https://www.python.org/ftp/python/3.11.9/python-3.11.9-amd64.exe
          echo "âœ… Python installer downloaded"
        else
          echo "âœ… Python installer already exists"
        fi

    - name: Build Windows executable with Wine + Windows Python (under Xvfb)
      id: build
      continue-on-error: true
      working-directory: ${{ github.workspace }}
      run: |
        echo "ğŸš€ Building TRUE Windows PE executable using Wine + Windows Python..."
        echo "ğŸ“¦ Installing Wine GUI helpers and Winetricks dependencies..."
        sudo apt-get update -qq
        sudo apt-get install -y --no-install-recommends \
          xvfb \
          cabextract \
          p7zip-full \
          unzip \
          winbind
        echo "âœ… Dependencies installed"

        # Create logs directory early
        mkdir -p logs/ build/ dist/

        echo "ğŸ–¥ï¸ Running build under virtual X server for Wine GUI support..."
        chmod +x build_windows.sh

        # Set build environment variables for better logging
        export BUILD_LOG="logs/github_actions_build_$(date +%Y%m%d_%H%M%S).log"
        export CI=true
        export GITHUB_ACTIONS=true

        # Run build with enhanced error capture
        set +e  # Don't exit on error, we want to capture it
        xvfb-run --auto-servernum --server-args="-screen 0 1024x768x24" \
          ./build_windows.sh --clean --create-installer --verbose 2>&1 | tee "logs/build_output.log"
        BUILD_EXIT_CODE=$?
        set -e

        echo "BUILD_EXIT_CODE=$BUILD_EXIT_CODE" >> $GITHUB_ENV
        echo "Build completed with exit code: $BUILD_EXIT_CODE"

        # Always create a build summary, regardless of success/failure
        echo "## Build Summary" >> $GITHUB_STEP_SUMMARY
        echo "- **Exit Code:** $BUILD_EXIT_CODE" >> $GITHUB_STEP_SUMMARY
        echo "- **Build Time:** $(date)" >> $GITHUB_STEP_SUMMARY
        echo "- **Wine Version:** $(wine --version 2>/dev/null || echo 'N/A')" >> $GITHUB_STEP_SUMMARY

        # Check if executable was actually created (critical verification)
        if [ -f "dist/SCADA-IDS-KC.exe" ]; then
          EXECUTABLE_SIZE=$(stat -c%s "dist/SCADA-IDS-KC.exe" 2>/dev/null || echo "0")
          echo "- **Executable:** âœ… Created (${EXECUTABLE_SIZE} bytes)" >> $GITHUB_STEP_SUMMARY
          echo "EXECUTABLE_VERIFIED=true" >> $GITHUB_ENV
        else
          echo "- **Executable:** âŒ NOT FOUND" >> $GITHUB_STEP_SUMMARY
          echo "EXECUTABLE_VERIFIED=false" >> $GITHUB_ENV
          # Force failure even if build reported success
          BUILD_EXIT_CODE=1
        fi

        if [ $BUILD_EXIT_CODE -eq 0 ] && [ "${EXECUTABLE_VERIFIED:-false}" = "true" ]; then
          echo "- **Status:** âœ… SUCCESS" >> $GITHUB_STEP_SUMMARY
        else
          echo "- **Status:** âŒ FAILED" >> $GITHUB_STEP_SUMMARY
          echo "- **Error Details:** Check build logs for detailed error information" >> $GITHUB_STEP_SUMMARY
        fi

        # List all generated files for debugging
        echo "### Generated Files" >> $GITHUB_STEP_SUMMARY
        echo "\`\`\`" >> $GITHUB_STEP_SUMMARY
        find . -name "*.exe" -o -name "*.log" -o -name "*.txt" | head -20 >> $GITHUB_STEP_SUMMARY
        echo "\`\`\`" >> $GITHUB_STEP_SUMMARY

        # Additional debugging for missing executable
        if [ "${EXECUTABLE_VERIFIED:-false}" = "false" ]; then
          echo "### Debug Information" >> $GITHUB_STEP_SUMMARY
          echo "\`\`\`" >> $GITHUB_STEP_SUMMARY
          echo "Contents of dist/:" >> $GITHUB_STEP_SUMMARY
          ls -la dist/ 2>/dev/null || echo "dist/ directory not found" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "Contents of build/:" >> $GITHUB_STEP_SUMMARY
          ls -la build/ 2>/dev/null || echo "build/ directory not found" >> $GITHUB_STEP_SUMMARY
          echo "\`\`\`" >> $GITHUB_STEP_SUMMARY

          # Show critical diagnostic results directly in GitHub Actions summary
          echo "### Critical Diagnostic Results" >> $GITHUB_STEP_SUMMARY
          echo "\`\`\`" >> $GITHUB_STEP_SUMMARY

          # PyInstaller import test result
          if [ -f "logs/pyinstaller_import_test.log" ]; then
            echo "PyInstaller Import Test:" >> $GITHUB_STEP_SUMMARY
            cat logs/pyinstaller_import_test.log >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
          fi

          # PyInstaller CLI test result
          if [ -f "logs/pyinstaller_help_test.log" ]; then
            echo "PyInstaller CLI Test:" >> $GITHUB_STEP_SUMMARY
            head -5 logs/pyinstaller_help_test.log >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
          fi

          # Ultra minimal test result
          if [ -f "logs/ultra_minimal_test.log" ]; then
            echo "Ultra Minimal Test Result:" >> $GITHUB_STEP_SUMMARY
            tail -10 logs/ultra_minimal_test.log >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
          fi

          # Python verification result
          if [ -f "logs/python_verification.log" ]; then
            echo "Python Verification:" >> $GITHUB_STEP_SUMMARY
            cat logs/python_verification.log >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
          fi

          # Environment dump key info
          if [ -f "logs/environment_dump.log" ]; then
            echo "Environment Summary:" >> $GITHUB_STEP_SUMMARY
            grep -A 5 "PYTHON ENVIRONMENT\|PYINSTALLER ENVIRONMENT" logs/environment_dump.log >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
          fi

          echo "\`\`\`" >> $GITHUB_STEP_SUMMARY
        fi

        exit $BUILD_EXIT_CODE
        
    - name: Verify Windows PE executable
      if: always()
      run: |
        echo "ğŸ“‹ Verifying build results..."

        # Check if build was successful
        if [ "${BUILD_EXIT_CODE:-1}" -eq 0 ]; then
          echo "âœ… Build reported success, verifying executable..."

          if [ -f "dist/SCADA-IDS-KC.exe" ]; then
            echo "âœ… Executable found"
            ls -lh dist/SCADA-IDS-KC.exe
            file_type=$(file dist/SCADA-IDS-KC.exe)
            echo "ğŸ“Š File type: $file_type"
            echo "ğŸ“Š File size: $(ls -lh dist/SCADA-IDS-KC.exe | awk '{print $5}')"

            # Verify it's a TRUE Windows PE executable
            if echo "$file_type" | grep -q "PE32.*Windows"; then
              echo "ğŸ‰ SUCCESS: TRUE Windows PE executable created!"
              echo "EXECUTABLE_VERIFIED=true" >> $GITHUB_ENV
            else
              echo "âŒ FAILED: Not a Windows PE executable!"
              echo "File type: $file_type"
              echo "EXECUTABLE_VERIFIED=false" >> $GITHUB_ENV
            fi
          else
            echo "âŒ Executable not found despite successful build"
            echo "EXECUTABLE_VERIFIED=false" >> $GITHUB_ENV
            ls -la dist/ || echo "dist/ directory not found"
          fi
        else
          echo "âŒ Build failed with exit code: ${BUILD_EXIT_CODE:-unknown}"
          echo "EXECUTABLE_VERIFIED=false" >> $GITHUB_ENV

          # Still check what files were created for debugging
          echo "ğŸ“ Checking for any generated files..."
          ls -la dist/ 2>/dev/null || echo "dist/ directory not found"
          ls -la build/ 2>/dev/null || echo "build/ directory not found"
          ls -la logs/ 2>/dev/null || echo "logs/ directory not found"
        fi
        
    - name: Create build info
      if: always()
      run: |
        echo "Creating build information file..."
        mkdir -p dist/

        cat > dist/BUILD_INFO.txt << EOF
        SCADA-IDS-KC Windows PE Build Information
        ========================================

        Build Date: $(date -u)
        Git Commit: ${{ github.sha }}
        Git Branch: ${{ github.ref_name }}
        Python Version: ${{ env.PYTHON_VERSION }}
        Build Environment: GitHub Actions Ubuntu 22.04 + Wine + Windows Python
        Build Method: TRUE Windows PE cross-compilation (not fake Linux rename!)

        Build Status: $([ "${BUILD_EXIT_CODE:-1}" -eq 0 ] && echo "SUCCESS" || echo "FAILED (exit code: ${BUILD_EXIT_CODE:-unknown})")
        Executable Verified: ${EXECUTABLE_VERIFIED:-false}

        File Information:
        $(if [ -f "dist/SCADA-IDS-KC.exe" ]; then ls -lh dist/SCADA-IDS-KC.exe; file dist/SCADA-IDS-KC.exe; else echo "Executable not found"; fi)

        Build Triggered By: ${{ github.event_name }}
        Actor: ${{ github.actor }}

        Environment Details:
        Wine Version: $(wine --version 2>/dev/null || echo "N/A")
        Windows Python: $(wine python.exe --version 2>/dev/null || echo "N/A")

        Generated Files:
        $(find . -name "*.exe" -o -name "*.log" -o -name "*.txt" | head -20 || echo "No files found")
        EOF

        echo "Build info created successfully"
        
    - name: Prepare artifacts for upload
      if: always()
      run: |
        echo "ğŸ“¦ Preparing artifacts for upload..."

        # Create artifacts directory
        mkdir -p artifacts/executables artifacts/logs artifacts/debug

        # Copy executable if it exists
        if [ -f "dist/SCADA-IDS-KC.exe" ]; then
          cp dist/SCADA-IDS-KC.exe artifacts/executables/
          echo "âœ… Executable copied to artifacts"
        else
          echo "âŒ No executable found to copy"
        fi

        # Copy build info (always exists now)
        cp dist/BUILD_INFO.txt artifacts/executables/ 2>/dev/null || echo "No BUILD_INFO.txt found"

        # Copy any zip files
        cp dist/*.zip artifacts/executables/ 2>/dev/null || echo "No zip files found"

        # Copy all logs
        cp -r logs/* artifacts/logs/ 2>/dev/null || echo "No logs directory found"

        # Copy build reports
        cp build_report_*.txt artifacts/logs/ 2>/dev/null || echo "No build reports found"

        # Copy error reports and failure markers
        cp logs/error_report_*.txt artifacts/debug/ 2>/dev/null || echo "No error reports found"
        cp build_failure.env artifacts/debug/ 2>/dev/null || echo "No failure marker found"

        # Copy PyInstaller build directory for debugging
        if [ -d "build" ]; then
          # Copy only log files and important debug info, not the entire build
          find build -name "*.log" -exec cp {} artifacts/debug/ \; 2>/dev/null || true
          find build -name "warn-*.txt" -exec cp {} artifacts/debug/ \; 2>/dev/null || true
        fi

        # Create a summary of what we're uploading
        echo "=== Artifact Summary ===" > artifacts/ARTIFACT_SUMMARY.txt
        echo "Build Date: $(date)" >> artifacts/ARTIFACT_SUMMARY.txt
        echo "Build Exit Code: ${BUILD_EXIT_CODE:-unknown}" >> artifacts/ARTIFACT_SUMMARY.txt
        echo "Executable Verified: ${EXECUTABLE_VERIFIED:-false}" >> artifacts/ARTIFACT_SUMMARY.txt
        echo "" >> artifacts/ARTIFACT_SUMMARY.txt
        echo "Files included:" >> artifacts/ARTIFACT_SUMMARY.txt
        find artifacts -type f | sort >> artifacts/ARTIFACT_SUMMARY.txt

        echo "ğŸ“¦ Artifacts prepared successfully"

    - name: Upload build artifacts (executables)
      if: always()
      uses: actions/upload-artifact@v4
      with:
        name: windows-executable-${{ github.sha }}
        path: |
          artifacts/executables/
          artifacts/ARTIFACT_SUMMARY.txt
        retention-days: 30
        if-no-files-found: warn

    - name: Upload build logs and debug info
      if: always()
      uses: actions/upload-artifact@v4
      with:
        name: build-logs-${{ github.sha }}
        path: |
          artifacts/logs/
          artifacts/debug/
          artifacts/ARTIFACT_SUMMARY.txt
        retention-days: 7
        if-no-files-found: warn
        
    - name: Create release (prefer native Windows build)
      if: (startsWith(github.ref, 'refs/tags/v') || github.event.inputs.create_release == 'true') && env.EXECUTABLE_VERIFIED == 'true'
      uses: softprops/action-gh-release@v1
      with:
        files: |
          dist/SCADA-IDS-KC.exe
          dist/BUILD_INFO.txt
          dist/*.zip
        name: SCADA-IDS-KC ${{ github.ref_name }}
        body: |
          ## SCADA-IDS-KC Windows Release
          
          ### ğŸš€ Features
          - Network Intrusion Detection System
          - Machine Learning-based SYN flood detection
          - Cross-platform GUI with PyQt6
          - Real-time packet capture with Scapy
          - System notifications
          
          ### ğŸ“¦ Installation
          1. Download `SCADA-IDS-KC.exe`
          2. Install [Npcap](https://npcap.com/) for packet capture
          3. Run the executable
          
          ### ğŸ§ª System Requirements
          - Windows 10/11 (64-bit)
          - Administrator privileges (for packet capture)
          - Npcap driver
          
          ### ğŸ“‹ Build Information
          - Built with Python ${{ env.PYTHON_VERSION }}
          - TRUE Windows PE executable (Wine + Windows Python cross-compilation)
          - Built on Ubuntu 22.04 with modern Wine 10.0+
          - Commit: ${{ github.sha }}
          - Build Date: $(date -u)
          
          ### ğŸ”§ Usage
          ```cmd
          # GUI Mode
          SCADA-IDS-KC.exe
          
          # CLI Mode
          SCADA-IDS-KC.exe --cli --status
          SCADA-IDS-KC.exe --help
          ```
        draft: false
        prerelease: ${{ contains(github.ref, 'beta') || contains(github.ref, 'alpha') }}
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

  # Native Windows build (primary approach since Wine has issues)
  build-windows-native:
    runs-on: windows-latest
    steps:
    - uses: actions/checkout@v4

    - name: Set up Python
      uses: actions/setup-python@v4
      with:
        python-version: '3.11'

    - name: Install dependencies
      run: |
        echo "ğŸ“¦ Installing Python dependencies..."
        pip install --upgrade pip
        pip install -r requirements.txt
        pip install "pyinstaller>=6.14,<7" pyinstaller-hooks-contrib

    - name: Build Windows executable with PyInstaller
      run: |
        echo "ğŸš€ Building Windows executable with native PyInstaller..."

        # Create dist and logs directories
        New-Item -ItemType Directory -Force -Path dist, logs, build

        # Build with PyInstaller using onefile approach
        pyinstaller --onefile `
          --name SCADA-IDS-KC `
          --hidden-import=scada_ids `
          --hidden-import=ui `
          --hidden-import=pydoc `
          --collect-all sklearn `
          --collect-all scipy `
          --collect-all numpy `
          --collect-all joblib `
          --add-data "config;config" `
          --noconfirm `
          --clean `
          --log-level DEBUG `
          --distpath dist `
          --workpath build `
          main.py

    - name: Verify Windows executable
      run: |
        echo "ğŸ“‹ Verifying Windows executable..."
        if (Test-Path "dist/SCADA-IDS-KC.exe") {
          echo "âœ… Executable created successfully"
          $size = (Get-Item "dist/SCADA-IDS-KC.exe").Length
          echo "ğŸ“Š File size: $size bytes"

          # Test if it's a valid PE executable
          $fileInfo = Get-Command "dist/SCADA-IDS-KC.exe" -ErrorAction SilentlyContinue
          if ($fileInfo) {
            echo "âœ… Valid Windows PE executable"
          } else {
            echo "âš ï¸ File exists but may not be a valid executable"
          }
        } else {
          echo "âŒ Executable not found"
          echo "Contents of dist/:"
          Get-ChildItem dist/ -ErrorAction SilentlyContinue
          exit 1
        }

    - name: Create build info
      run: |
        echo "Creating build information file..."
        @"
        SCADA-IDS-KC Windows Native Build Information
        ==========================================

        Build Date: $(Get-Date -Format 'yyyy-MM-dd HH:mm:ss UTC')
        Git Commit: ${{ github.sha }}
        Git Branch: ${{ github.ref_name }}
        Python Version: $(python --version)
        Build Environment: GitHub Actions Windows Server 2022
        Build Method: Native Windows PyInstaller (not Wine cross-compilation)

        File Information:
        $(if (Test-Path "dist/SCADA-IDS-KC.exe") {
          "Size: $((Get-Item 'dist/SCADA-IDS-KC.exe').Length) bytes"
          "Created: $((Get-Item 'dist/SCADA-IDS-KC.exe').CreationTime)"
        } else {
          "Executable not found"
        })

        Build Triggered By: ${{ github.event_name }}
        Actor: ${{ github.actor }}

        PyInstaller Version: $(pip show pyinstaller | Select-String "Version")
        "@  | Out-File -FilePath "dist/BUILD_INFO.txt" -Encoding UTF8

    - name: Upload Windows executable
      uses: actions/upload-artifact@v4
      with:
        name: windows-executable-native-${{ github.sha }}
        path: |
          dist/SCADA-IDS-KC.exe
          dist/BUILD_INFO.txt
        retention-days: 30
        if-no-files-found: error

    - name: Upload build logs
      if: always()
      uses: actions/upload-artifact@v4
      with:
        name: build-logs-native-${{ github.sha }}
        path: |
          build/
        retention-days: 7
        if-no-files-found: warn

  test-windows:
    runs-on: windows-latest
    needs: [build-windows, build-windows-native]
    if: (github.event_name == 'pull_request' || github.event_name == 'push') && (needs.build-windows.result == 'success' || needs.build-windows-native.result == 'success')
    
    steps:
    - name: Download Windows executable (try native first)
      uses: actions/download-artifact@v4
      with:
        name: windows-executable-native-${{ github.sha }}
        path: dist/
      continue-on-error: true

    - name: Download Wine executable (fallback)
      if: failure()
      uses: actions/download-artifact@v4
      with:
        name: windows-executable-${{ github.sha }}
        path: dist/
        
    - name: Test Windows executable
      run: |
        echo "ğŸ§ª Testing Windows executable on native Windows..."
        
        # Check if executable exists
        if (Test-Path "dist/SCADA-IDS-KC.exe") {
          Write-Host "âœ… Executable found"
          Get-ChildItem "dist/SCADA-IDS-KC.exe" | Format-List
        } else {
          Write-Host "âŒ Executable not found"
          exit 1
        }
        
        # Test version command (should work without admin privileges)
        Write-Host "ğŸš€ Testing version command..."
        try {
          $output = & "dist/SCADA-IDS-KC.exe" --version 2>&1
          Write-Host "âœ… Version command successful: $output"
        } catch {
          Write-Host "âš ï¸ Version command failed: $_"
        }
        
        # Test help command
        Write-Host "ğŸ“– Testing help command..."
        try {
          $output = & "dist/SCADA-IDS-KC.exe" --help 2>&1
          Write-Host "âœ… Help command successful"
        } catch {
          Write-Host "âš ï¸ Help command failed: $_"
        }
        
        Write-Host "ğŸ‰ Windows testing completed"
